理念: 使现有技术更加实用 —— 不创建新的框架
作用: 整合现有框架技术

优点
  轻量级: 使用框架不需继承相应的类；不需实现相应的接口
  IOC容器: 控制反转
  AOP: 面向切面编程
  对事务的支持
  对框架的支持
  
内容
  spring-overview.png
Beans: 创建对象 - Core: 核心代码 - Context: 上下文 - SpEL: 表达式
junit test

IOC 控制反转
  应用程序本身创建(service层) -> 客户端创建，应用程序接收对象(调用service层)
  将对象具体的实现分离出来，可以更多的关注业务
  真正面向接口编程，实现解耦

bean: 由spring容器创建管理的java对象(cn.pjkbalance.study.spring.spring1)
  Hello对象及对象属性均由Spring容器创建/设置；该过程中:
  控制的内容: 指谁来控制对象的创建；传统的程序由程序本身控制，使用Spring后由Spring控制
  反转: 权限的转移；程序本身创建对象，变为程序被动接收对象(主动 -> 被动)

实现: 通过 ioc 容器 - BeanFactory 实现
ref: 引用由spring创建的对象
创建、管理对象 (生命周期)

使用ioc创建对象的方式 (cn.jk.study.spring3)
通过无参构造函数创建
通过有参构造函数创建
通过工厂方法创建

<beans>
  <!-- 导入已有的xml配置 -->
  <import resource="xxx.xml"/>
  <!-- id: bean 的标识符，需要唯一 -->
  <!-- 若没有 id 则 name 为标识符 -->
  <!-- 若有 id 则 name 为别名，可为多个，分隔符很多 -->
  <!-- 若 id name 均未设置，则可通过 class 获取对象 -->
  <bean id="beanName" name="user1,user2 user3(别名)" class="beanClass">
    <!--有参构造函数-->
    <constructor-arg name="argName" value="argValue"/>
  </bean>
  <alias name="beanName(定义好的 bean)" alias="user1,user2,...(别名)" />
</beans>

依赖注入
依赖: bean 对象依赖于 Spring 容器创建； bean 对象依赖于资源
注入: bean 对象所依赖的资源由 spring 容器设置、装配
构造器注入
setter注入
  被注入的属性必须有set方法 - 见附录

bean 作用域 - scope
  singleton: 单例 - 整个容器中只有一个对象实例
  prototype: 原型模式 - 每次获取 bean 均产生一个新的对象
  request: 每次请求时创建一个新的对象
  session: 会话范围内只有一个对象
  global session: 只在 protlet 下有用，表示 application
  application: 一个应用范围内只有一个对象

自动装配: 简化 sprint 配置 - 可配置 beans default-autowire - 不推荐；最好使用注解
<bean id="" class="" autowire="no(不使用)/byName/byType/constructor"/>
等价
<bean id="" class="">
  <property name="" ref=""/>
</bean>


静态代理 (cn.jk.study.spring4)
proxy.png
角色分析
  抽象角色: 一般使用接口或抽象类实现 (Rent)
  真实角色: 被代理的角色 (Host)
  代理角色: 代理真实角色 (Proxy)，一般会做一些附属操作
  客户端: 使用代理角色进行操作 (Client)
优点
  使真实角色更加纯粹，不在关注公共功能
  公共功能由代理完成，实现业务分工
  公共业务发生改变或扩展时，变得更加集中和方便
缺点
  更多的类 (代理类)，工作两边打

动态代理 (cn.jk.study.spring5)
  角色与静态代理一致
  代理类是动态生成的
动态代理分为
  基于接口的动态代理 - jdk动态代理原理
  基于类的动态代理 - cglib
目前使用 javasist 生成动态代理

jdk 动态代理
Proxy 类
InvocationHandler 接口 - 代理实例 (Proxy) 的 调用处理程序 ( rent() ) 实现的接口
每个 代理实例 具有一个 关联的 调用处理程序。对 代理实例 调用方法时 (proxy.rent())，将对方法进行编码并将其指派给他调用处理程序的 invoke 方法
invoke(Object proxy, Method method, Object[] args)







































附录
settler注入
  <!-- 常量注入 -->
  <bean id="" class="">
    <property name="propertyName" value="propertyValue"/>
  </bean>
  <!-- bean注入 -->
  <bean id="" class="">
    <property name="propertyName" ref="beanId"/>
  </bean>
  <!-- 数组注入 -->
  <bean id="" class="">
    <property name="propertyName">
	  <array>
	    <value>1</value>
		<value>2</value>
	  </array>
	</property>
  </bean>
  <!-- List 注入 -->
  <bean id="" class="">
    <property name="propertyName">
	  <list>
	    <value>1</value>
		<value>2</value>
	  </list>
	</property>
  </bean>
  <!-- Map 注入 -->
  <bean id="" class="">
    <property name="propertyName">
	  <map>
	    <entry key="keyName" value="keyValue"/>
		<entry>
		  <key><value>keyName</value></key>
		  <value>keyValue</value>
		</entry>
	  </list>
	</property>
  </bean>
  <!-- Set 注入 -->
  <bean id="" class="">
    <property name="propertyName">
	  <set>
	    <value><value/>
	    <value><value/>
	  </set>
	</property>
  </bean>
  <!-- Null 注入 -->
  <bean id="" class="">
    <property name="propertyName"><null/></property>
  </bean>
  <!-- Property 注入 -->
  <bean id="" class="">
    <property name="propertyName">
	  <props>
	    <prop key="">value</prop>
	  </props>
	</property>
  </bean>
  <!-- P(prop)命名空间注入 -->
  <bean id="" class="" p:xxx="xxxValue"/>
  <!-- C(class)命名空间注入 -->
  <bean id="" class="" c:xxx="xxxValue"/>
